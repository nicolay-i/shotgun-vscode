**Бизнес-цель рефакторинга:** Улучшить поддерживаемость и тестируемость кодовой базы, чтобы упростить добавление новых AI-провайдеров (например, Anthropic Claude) и кастомных фич, снизив при этом риск появления регрессионных багов.

---

### Общий анализ
Кодовая база имеет хорошую начальную структуру:
*   **Паттерн "Стратегия"** для провайдеров (`IAiProvider`) — отлично.
*   **Паттерн "Фабрика"** для создания провайдеров (`ProviderFactory`) — хорошо.
*   **Абстракции для зависимостей** (`IFileSystemService`, `ISecretStorageService`) — превосходно для тестирования.
*   **Frontend (MobX + React)** хорошо структурирован.

**Ключевые проблемные зоны (точки роста):**
1.  **"Божественный объект" (`God Object`):** Класс `ShotgunPanel` делает слишком много. Он управляет UI, парсит сообщения, координирует сервисы, работает с файловой системой. Это нарушает Принцип единственной ответственности (SRP).
2.  **Прямое создание зависимостей:** `ShotgunPanel` создает экземпляры сервисов (`new ApiService()`, `new FileSystemService()`) напрямую. Это затрудняет модульное тестирование и замену реализаций (Dependency Inversion Principle).
3.  **Нарушение Принципа открытости/закрытости (OCP):** Метод `generatePayloadPreview` в `ApiService` использует `switch`, который придется изменять при добавлении каждого нового провайдера.
4.  **Смешение ответственности на фронтенде:** `ApiStore` занимается и состоянием UI, и логикой персистентности в `localStorage`, и общением с `SecretStorage`.
5.  **Отсутствие тестов:** Самый большой риск. Любое изменение — это "прыжок веры".

---

## План рефакторинга

### Шаг 0: Обеспечение безопасности (Написание тестов)

**Принцип:** Мы не можем улучшать то, что не можем измерить. Тесты — наша страховка от регрессий.

**Действие:**
1.  Настроить тестовую среду `Jest` (уже есть в `package.json`, нужно настроить конфигурацию для TypeScript и моки для VS Code API).
2.  Написать **юнит-тесты** для "чистых" и изолированных частей системы:
    *   `ProviderFactory`: Проверить, что `getProvider` возвращает правильные инстансы и бросает ошибку для неизвестных провайдеров.
    *   `ApiService.formatPrompt`: Проверить форматирование с шаблоном и без него.
    *   `FileSystemService`: Используя библиотеку `mock-fs`, протестировать фильтрацию (`shouldIgnoreFile`, `isTextFile`) и построение дерева.
    *   `CustomProvider.validateUrl`: Протестировать валидацию для корректных, некорректных и запрещенных URL.
3.  Написать **характеризационные (characterization) тесты** для ключевых, сложных частей. Эти тесты не проверяют *правильность*, а фиксируют *текущее* поведение системы.
    *   **Для `ShotgunPanel`:** Создать моки для `vscode`, `IFileSystemService`, `IApiService`, `ISecretStorageService`. Симулировать входящие сообщения от Webview (`onDidReceiveMessage`) и проверять, какие сообщения отправляются обратно (`panel.webview.postMessage`). Это наш главный защитный механизм.

**Ценность:**
*   Создает "сеть безопасности", которая немедленно сообщит нам, если мы что-то сломали.
*   Документирует текущее поведение системы.
*   Позволяет проводить последующие шаги рефакторинга с уверенностью.

**Проверка:**
*   Тесты запущены и успешно проходят.
*   Покрытие кода для ключевых модулей (утилиты, фабрика) составляет >80%.

---

### Шаг 1: Внедрение зависимостей (Dependency Injection) в `ShotgunPanel`

**Действие:** Избавиться от `new` внутри `ShotgunPanel`. Зависимости должны приходить снаружи.

1.  Изменить конструктор `ShotgunPanel`, чтобы он принимал `IApiService`, `IFileSystemService` и `ISecretStorageService` в качестве аргументов.
2.  В файле `extension.ts` (в функции `activate`) создать экземпляры всех сервисов и передать их в `ShotgunPanel.createOrShow`, а затем в конструктор.

**Ценность:**
*   **Тестируемость:** Теперь мы можем легко подменить сервисы моками в тестах `ShotgunPanel`.
*   **Гибкость:** Упрощает замену реализаций в будущем (например, `InMemoryFileSystemService` для тестов).
*   **Следование SOLID (Dependency Inversion Principle):** `ShotgunPanel` больше не зависит от *конкретных* реализаций, а только от *абстракций* (интерфейсов).

**Пример кода (До/После):**

*   **ДО (`ShotgunPanel.ts`):**
    ```typescript
    // ...
    private readonly _apiService: ApiService;
    private readonly _fileSystemService: IFileSystemService;

    private constructor(...) {
        // ...
        this._apiService = new ApiService();
        this._fileSystemService = new FileSystemService();
        // ...
    }
    ```

*   **ПОСЛЕ (`ShotgunPanel.ts`):**
    ```typescript
    // ...
    private readonly _apiService: IApiService; // Используем интерфейс
    private readonly _fileSystemService: IFileSystemService;

    private constructor(
        panel: vscode.WebviewPanel, 
        extensionUri: vscode.Uri, 
        services: {
            apiService: IApiService;
            fileSystemService: IFileSystemService;
            secretStorageService: ISecretStorageService;
        }
    ) {
        this._panel = panel;
        this._extensionUri = extensionUri;
        this._apiService = services.apiService;
        this._fileSystemService = services.fileSystemService;
        this._secretStorageService = services.secretStorageService;
        // ...
    }
    ```

*   **ПОСЛЕ (`extension.ts`):**
    ```typescript
    import { ApiService } from './ApiService';
    import { FileSystemService } from './services/FileSystemService';
    import { VsCodeSecretStorageService } from './services/VsCodeSecretStorageService';
    // ...

    export function activate(context: vscode.ExtensionContext) {
        const fileSystemService = new FileSystemService();
        const secretStorageService = new VsCodeSecretStorageService(context);
        const apiService = new ApiService(); // ApiService пока не имеет зависимостей

        const disposable = vscode.commands.registerCommand('ai-assistant.openPanel', () => {
            ShotgunPanel.createOrShow(context.extensionUri, {
                apiService,
                fileSystemService,
                secretStorageService
            });
        });
        // ...
    }
    ```

**Проверка:**
*   Запустить все тесты из Шага 0. Они должны проходить без изменений.
*   Вручную запустить расширение и убедиться, что все функции (загрузка файлов, отправка запроса) работают как прежде.

---

### Шаг 2: Устранение нарушения OCP в `ApiService`

**Действие:** Перенести логику генерации `payload` в соответствующие провайдеры.

1.  Добавить новый метод в интерфейс `IAiProvider`:
    `generatePayload(systemPrompt: string, userPrompt: string, config: ApiConfig): object;`
2.  Реализовать этот метод в каждом классе-провайдере (`OpenAiProvider`, `GeminiProvider`, и т.д.).
3.  Изменить `ApiService.generatePayloadPreview`, чтобы он просто вызывал метод провайдера, вместо использования `switch`.

**Ценность:**
*   **Расширяемость (Open/Closed Principle):** Теперь для добавления нового провайдера достаточно создать новый класс, реализующий `IAiProvider`. Менять `ApiService` не нужно.
*   **Инкапсуляция:** Логика, специфичная для каждого провайдера, теперь полностью находится внутри его класса.

**Пример кода (До/После):**

*   **ПОСЛЕ (`IAiProvider.ts`):**
    ```typescript
    export interface IAiProvider {
        sendRequest(systemPrompt: string, userPrompt: string, config: ApiConfig): Promise<string>;
        generatePayload(systemPrompt: string, userPrompt: string, config: ApiConfig): object;
    }
    ```

*   **ПОСЛЕ (`OpenAiProvider.ts`):**
    ```typescript
    public generatePayload(systemPrompt: string, userPrompt: string, config: ApiConfig): object {
        return {
            model: config.model || 'gpt-4',
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userPrompt }
            ],
            temperature: 0.7,
        };
    }
    ```

*   **ПОСЛЕ (`ApiService.ts`):**
    ```typescript
    generatePayloadPreview(
        prompt: string,
        selectedFiles: SelectedFile[],
        config: ApiConfig,
        template?: PromptTemplate
    ): { systemPrompt: string; userPrompt: string; payload: any } {
        const { systemPrompt, userPrompt } = this.formatPrompt(template, prompt, selectedFiles);
        const provider = ProviderFactory.getProvider(config.provider);
        const payload = provider.generatePayload(systemPrompt, userPrompt, config);
        
        return { systemPrompt, userPrompt, payload };
    }
    ```

**Проверка:**
*   Написать новые юнит-тесты для метода `generatePayload` в каждом провайдере.
*   Запустить все существующие тесты. Они должны проходить.
*   Вручную проверить, что функция "Предпросмотр" в UI работает корректно для всех провайдеров.

---

### Шаг 3: Декомпозиция "Божественного объекта" `ShotgunPanel`

**Действие:** Выделить всю логику обработки сообщений в отдельный класс `MessageHandler`.

1.  Создать новый класс `MessageHandler`.
2.  Его конструктор должен принимать все необходимые сервисы (`IApiService`, `IFileSystemService`, и т.д.), которые он получит от `ShotgunPanel`. Он также должен принимать экземпляр `vscode.WebviewPanel` для отправки ответных сообщений.
3.  Перенести все `async _handle...` методы из `ShotgunPanel` в `MessageHandler`, сделав их публичными.
4.  Создать в `MessageHandler` один публичный метод `handleMessage(message: Message)`. Внутри этого метода будет `switch`, который вызывает соответствующие `handle...` методы.
5.  `ShotgunPanel` теперь будет только создавать экземпляр `MessageHandler` и в `_setWebviewMessageListener` просто вызывать `this._messageHandler.handleMessage(message)`.

**Ценность:**
*   **Принцип единственной ответственности (SRP):** `ShotgunPanel` теперь отвечает только за жизненный цикл UI-панели VS Code. `MessageHandler` отвечает за всю бизнес-логику и координацию сервисов.
*   **Тестируемость:** `MessageHandler` становится очень легко тестируемым классом, так как он не содержит UI-кода VS Code, а просто работает с данными и сервисами.

**Пример кода (До/После):**

*   **ПОСЛЕ (Новый файл `MessageHandler.ts`):**
    ```typescript
    export class MessageHandler {
        constructor(
            private panel: vscode.WebviewPanel,
            private apiService: IApiService,
            private fileSystemService: IFileSystemService
            //...
        ) {}

        public async handleMessage(message: Message): Promise<void> {
            switch (message.type) {
                case 'getFiles':
                    await this.handleGetFiles();
                    break;
                // ... все остальные case'ы
            }
        }

        private async handleGetFiles(): Promise<void> {
            // ... логика из ShotgunPanel._handleGetFiles
            this.panel.webview.postMessage({ type: 'fileTree', data: fileTree });
        }
        // ... все остальные обработчики
    }
    ```

*   **ПОСЛЕ (`ShotgunPanel.ts`):**
    ```typescript
    // ...
    private readonly _messageHandler: MessageHandler;

    private constructor(...) {
        // ...
        this._messageHandler = new MessageHandler(
            this._panel,
            this._apiService,
            this._fileSystemService,
            // ...
        );
        this._setWebviewMessageListener();
        // ...
    }

    private _setWebviewMessageListener() {
        this._panel.webview.onDidReceiveMessage(
            (message: Message) => {
                // Просто делегируем
                this._messageHandler.handleMessage(message).catch(error => {
                    this._panel.webview.postMessage({
                        type: 'error',
                        data: { message: error.message }
                    });
                });
            },
            null,
            this._disposables
        );
    }
    // Все методы _handle... удалены отсюда
    ```

**Проверка:**
*   Перенести и адаптировать характеризационные тесты для `ShotgunPanel` в полноценные юнит-тесты для `MessageHandler`.
*   Запустить все тесты.
*   Вручную проверить работоспособность всего расширения.

---


### Итог
После выполнения этих шагов мы получим кодовую базу, которая:
1.  **Надежна:** Покрыта тестами, минимизируя риск регрессий.
2.  **Гибка и расширяема:** Добавление нового AI-провайдера требует создания всего одного нового файла, не затрагивая ядро системы.
3.  **Поддерживаема:** Код разделен на небольшие классы с четкими обязанностями (`ShotgunPanel`, `MessageHandler`, `*Provider`), что упрощает понимание и модификацию.

Каждый шаг плана атомарен, измерим через тесты и приносит очевидную ценность, полностью соответствуя принципу "Не навреди".