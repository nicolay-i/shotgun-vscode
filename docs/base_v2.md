## Техническое Задание: Разработка VS Code расширения "AI Code Assistant"

### 1. Общая информация

*   **Название проекта:** AI Code Assistant
*   **Краткое описание:** Расширение для Visual Studio Code, предоставляющее AI-ассистента для анализа, рефакторинга, документирования и улучшения кода. Пользователь может выбирать файлы из проекта, задавать вопросы или задачи в свободной форме, использовать шаблоны промптов и получать развернутые ответы от языковой модели.
*   **Цель проекта:** Создать инструмент, который ускоряет и упрощает процесс работы с кодом, интегрируя возможности современных языковых моделей непосредственно в среду разработки VS Code.

### 2. Целевая аудитория

*   Разработчики программного обеспечения (от Junior до Senior), работающие в VS Code.
*   Технические писатели, документирующие код.
*   QA-инженеры, анализирующие код для написания тестов.

### 3. Основные возможности (Functional Requirements)

Проект состоит из двух основных частей: **Backend** (часть, работающая в окружении VS Code) и **Frontend** (пользовательский интерфейс в виде Webview).

#### 3.1. Интеграция с VS Code и Backend
*   **Активация:** Расширение должно добавлять иконку на панель действий (Activity Bar) VS Code, по клику на которую открывается основной интерфейс.
*   **Команда:** Должна быть зарегистрирована команда (например, `ai-assistant.openPanel`), которую можно вызвать через палитру команд (Ctrl/Cmd+Shift+P).
*   **Доступ к файловой системе:**
    *   Расширение должно уметь сканировать файловую структуру текущего открытого воркспейса (workspace).
    *   При сканировании должны игнорироваться системные и нерелевантные директории (например, `.git`, `node_modules`, `out/`, `dist/`, `.*`).
    *   Расширение должно уметь асинхронно читать содержимое текстовых файлов по запросу от Frontend.
*   **Взаимодействие с редактором:**
    *   Возможность открыть любой файл из дерева файлов в Webview в новой вкладке редактора VS Code.
    *   Возможность сохранить ответ от AI в новый файл (например, `response-YYYY-MM-DD.md`) в корне проекта и автоматически открыть его.
*   **Взаимодействие с AI сервисами:**
    *   Реализовать сервис (`ApiService`) для отправки запросов к различным LLM-провайдерам.
    *   Необходимо поддержать как минимум: **Google Gemini**, **OpenAI**, **OpenRouter** и возможность подключения к **кастомному (Custom) API-серверу**, совместимому с OpenAI API.
    *   Сервис должен формировать итоговый промпт, объединяя системный промпт (из шаблона), пользовательский запрос и содержимое всех выбранных файлов.
    *   Все запросы к API должны быть асинхронными и не блокировать интерфейс.

#### 3.2. Пользовательский интерфейс (Frontend - Webview)

Интерфейс должен быть реализован с использованием **React** и стилизован под нативный вид VS Code. Он должен состоять из двух основных панелей: левой для навигации по файлам и правой для взаимодействия с AI.

**Левая панель:**
*   **Дерево файлов (`FileTree`):**
    *   Отображение иерархической структуры файлов и папок проекта.
    *   Каждый элемент (файл/папка) должен иметь чекбокс для выбора.
    *   При выборе папки должны автоматически выбираться все вложенные файлы и папки.
    *   Реализовать "неопределенное" состояние (indeterminate) для чекбокса папки, если выбрана только часть ее содержимого.
    *   Состояние дерева (выбранные файлы, раскрытые папки) должно сохраняться между сессиями (использовать `localStorage`).
    *   Клик по названию файла должен инициировать его открытие в редакторе VS Code.

**Правая панель:**
*   **Настройки API (`ApiSettings`):**
    *   Сворачиваемый блок для управления настройками подключения.
    *   Выбор API-провайдера (Gemini, OpenAI, etc.).
    *   Поля для ввода API-ключей (тип `password`).
    *   Поля для кастомного URL и ключа (для провайдера "Custom").
    *   Поле для указания конкретной модели (например, `gpt-4`, `gemini-1.5-pro`).
    *   Настройки должны персистентно храниться в `localStorage`.
*   **Менеджер шаблонов (`TemplateManager`):**
    *   Интерфейс для управления шаблонами промптов.
    *   Отображение списка доступных шаблонов.
    *   Возможность создавать (`+ Новый шаблон`), редактировать и удалять пользовательские шаблоны. Встроенные шаблоны удалять нельзя.
    *   При выборе шаблона он становится активным для следующего запроса.
    *   Для каждого шаблона должны быть кнопки "Предпросмотр", "Редактировать", "Удалить" (для кастомных).
*   **Поле для ввода запроса (`PromptSection`):**
    *   Многострочное текстовое поле (`textarea`) для ввода пользователем задачи или вопроса.
    *   Текст в этом поле должен сохраняться между сессиями (`localStorage`).
*   **Список выбранных файлов (`SelectedFiles`):**
    *   Отображение списка путей к файлам, которые были выбраны в `FileTree`.
    *   Рядом с каждым файлом должна быть кнопка для его удаления из списка.
*   **Кнопки действий:**
    *   "Отправить": становится активной только если выбраны файлы и введен текст запроса.
    *   "Очистить": сбрасывает поле запроса, список выбранных файлов и состояние `FileTree`.
*   **Секция ответа (`ResponseSection`):**
    *   Область для отображения ответа от AI.
    *   Ответ должен быть отформатирован для удобного чтения (например, внутри тега `<pre>`).
    *   Кнопка "Сохранить", которая появляется после получения ответа и позволяет сохранить его в файл.
*   **Индикатор загрузки (`LoadingOverlay`):**
    *   Модальное окно или оверлей, который отображается на все время выполнения запроса к AI, блокируя интерфейс и информируя пользователя о том, что идет обработка.

#### 3.3. Система шаблонов промптов
*   **Структура шаблона (`PromptTemplate`):**
    *   `id`: Уникальный идентификатор.
    *   `name`: Название шаблона.
    *   `description`: Краткое описание.
    *   `systemPrompt`: Системный промпт, определяющий роль и поведение AI.
    *   `userPrompt`: Шаблон пользовательского запроса с плейсхолдерами.
    *   `isBuiltIn`: Флаг, указывающий, является ли шаблон встроенным.
*   **Плейсхолдеры:** В `userPrompt` должны поддерживаться переменные:
    *   `{{ЗАДАЧА}}`: Заменяется на текст, введенный пользователем.
    *   `{{FILES}}`: Заменяется на объединенное содержимое всех выбранных файлов.
*   **Редактор шаблонов (`TemplateEditor`):**
    *   Модальное окно для создания/редактирования шаблонов.
    *   Форма с полями для всех свойств шаблона.
    *   Валидация полей (название, промпты не должны быть пустыми).
*   **Предпросмотр шаблона (`PromptPreview`):**
    *   Модальное окно, показывающее, как будет выглядеть итоговый промпт.
    *   Показывает отдельно системный промпт, пользовательский шаблон и итоговый результат с подставленным текущим запросом и файлами.
    *   Кнопка "Использовать шаблон" для отправки запроса прямо из окна предпросмотра.

### 4. Пользовательские сценарии (User Cases)

*   **UC-1: Анализ кода**
    1. Пользователь открывает панель "AI Code Assistant".
    2. В дереве файлов он выбирает несколько файлов, которые хочет проанализировать.
    3. В поле "Введите ваш запрос" он пишет: "Объясни, как взаимодействуют эти компоненты. Есть ли здесь потенциальные проблемы с производительностью?".
    4. Нажимает "Отправить".
    5. Появляется индикатор загрузки.
    6. В секции ответа появляется подробное объяснение от AI.
    7. Пользователь доволен ответом и нажимает "Сохранить", чтобы создать markdown-файл с анализом.

*   **UC-2: Рефакторинг с использованием шаблона**
    1. Пользователь выбирает файл с "грязным" кодом.
    2. В "Менеджере шаблонов" он выбирает шаблон "План рефакторинга".
    3. В поле запроса он пишет цель: "Улучшить читаемость и разбить большую функцию на несколько мелких".
    4. Нажимает "Отправить".
    5. AI, используя системный промпт из шаблона, генерирует пошаговый план рефакторинга с объяснениями.

*   **UC-3: Создание и использование кастомного шаблона**
    1. Пользователь часто пишет юнит-тесты и хочет автоматизировать их генерацию.
    2. Он нажимает "Новый шаблон".
    3. В редакторе он создает шаблон "Генерация Unit-тестов":
        *   **Название:** "Сгенерировать Jest-тесты"
        *   **System Prompt:** "Ты — QA-инженер, специализирующийся на Jest и React Testing Library. Напиши исчерпывающие юнит-тесты для предоставленного кода..."
        *   **User Prompt:** "Напиши тесты для следующих файлов, сфокусируйся на: `{{ЗАДАЧА}}`. Код для тестирования: `{{FILES}}`"
    4. Сохраняет шаблон.
    5. Теперь, чтобы сгенерировать тесты, он выбирает файл с компонентом, выбирает свой новый шаблон, пишет в запросе "протестировать все ветки условной логики" и отправляет запрос.

### 5. Нефункциональные требования

*   **Производительность:** Сканирование дерева файлов не должно занимать много времени для средних проектов. Чтение файлов и запросы к AI должны быть полностью асинхронными.
*   **Безопасность:** API-ключи должны храниться локально на машине пользователя в `localStorage` и никогда не передаваться никуда, кроме как напрямую в API соответствующего провайдера. Использовать `Content-Security-Policy` для Webview.
*   **Надежность:** Расширение не должно падать при ошибках API (например, неверный ключ, недоступность сервиса). Ошибки должны корректно обрабатываться и отображаться пользователю.
*   **Юзабилити:** Интерфейс должен быть интуитивно понятным. Сохранение состояния (запроса, выбранных файлов) улучшает пользовательский опыт.

### 6. Технологический стек

*   **Backend (Extension):** TypeScript, Node.js, VS Code API.
*   **Frontend (Webview):** React, TypeScript, SASS/SCSS, MobX (для управления состоянием).
*   **Сборка:** Webpack для сборки Frontend, `tsc` для компиляции Backend.
*   **Зависимости:** `@google/generative-ai`, `phosphor-react` (для иконок), `mobx`, `mobx-react-lite`, `node-fetch` (если требуется).

### 7. Архитектура и взаимодействие компонентов

*   **`extension.ts`**: Точка входа. Регистрирует команду и создает `ShotgunPanel`.
*   **`ShotgunPanel.ts`**: "Мост" между VS Code и Webview.
    *   Создает и управляет Webview.
    *   Обрабатывает сообщения от Webview (`onDidReceiveMessage`).
    *   Отправляет данные в Webview (`postMessage`).
    *   Взаимодействует с `ApiService` и файловой системой.
*   **`ApiService.ts`**: Инкапсулирует логику общения с различными AI API.
*   **`App.tsx`**: Корневой компонент React-приложения в Webview. Инициализирует MobX stores и предоставляет контекст для дочерних компонентов.
*   **MobX Stores:**
    *   **`AppStore`**: Основной store, содержащий общее состояние приложения (загрузка, ошибки).
    *   **`FileStore`**: Управление деревом файлов, выбранными файлами, состоянием раскрытых папок.
    *   **`ApiStore`**: Настройки API провайдеров, API ключи, выбранная модель.
    *   **`TemplateStore`**: Управление шаблонами промптов (встроенными и пользовательскими).
    *   **`PromptStore`**: Текущий пользовательский запрос, выбранный шаблон, ответ от AI.
*   **Компоненты (`*.tsx`)**: Каждый компонент отвечает за свою часть UI, использует соответствующие stores через React Context или прямые импорты, обернут в `observer` для реактивности.
*   **Управление состоянием:**
    *   **MobX Store**: Централизованное управление состоянием приложения через MobX stores.
    *   **Компонентное состояние**: Локальное состояние UI компонентов через React state (`useState`) для простых случаев.
    *   **Персистентное состояние**: Долговременное состояние (настройки API, текст промпта, состояние дерева файлов, пользовательские шаблоны) сохраняется в `localStorage` и синхронизируется с MobX store при инициализации.
    *   **Реактивность**: Использование `observer` из `mobx-react-lite` для автоматического обновления компонентов при изменении observable состояния.

#### **Детали реализации MobX**

*   **Структура Store:**
    ```typescript
    class AppStore {
      @observable isLoading: boolean = false;
      @observable error: string | null = null;
      
      @action setLoading(loading: boolean) { this.isLoading = loading; }
      @action setError(error: string | null) { this.error = error; }
    }
    ```

*   **Персистентность:**
    *   Используется `autorun` для автоматического сохранения изменений observable полей в `localStorage`.
    *   При инициализации stores загружают сохраненные данные из `localStorage`.
    *   Чувствительные данные (API ключи) шифруются перед сохранением.

*   **Интеграция с React:**
    *   Компоненты оборачиваются в `observer` для автоматической подписки на изменения.
    *   Stores предоставляются через React Context для удобного доступа.
    *   Используется паттерн "computed values" для производных данных (например, список выбранных файлов).

*   **Производительность:**
    *   Применяется `runInAction` для группировки изменений состояния.
    *   Используется `reaction` для побочных эффектов (например, сохранение в localStorage).
    *   Избегается лишних ререндеров через правильное структурирование observable данных.

#### **Контракт взаимодействия (API `postMessage`)**

*   **Webview -> Extension:**
    *   `{ type: 'getFiles' }`: Запросить дерево файлов.
    *   `{ type: 'getFileContent', filePath: string }`: Запросить содержимое файла.
    *   `{ type: 'openFile', filePath: string }`: Открыть файл в редакторе.
    *   `{ type: 'submitToAI', prompt: string, selectedFiles: SelectedFile[], apiConfig: ApiConfig }`: Отправить запрос к AI.
    *   `{ type: 'saveResponse', content: string }`: Сохранить ответ в файл.
*   **Extension -> Webview:**
    *   `{ type: 'fileTree', data: FileNode[] }`: Отправить дерево файлов.
    *   `{ type: 'fileContent', data: { path: string, content: string } }`: Отправить содержимое файла.
    *   `{ type: 'aiResponse', data: string }`: Отправить ответ от AI.
    *   `{ type: 'loadingStart' }`: Сообщить о начале загрузки.
    *   `{ type: 'loadingEnd' }`: Сообщить об окончании загрузки.